{"version":3,"sources":["webpack://app/javascript/node_modules/graphql/version.mjs","webpack://app/javascript/node_modules/graphql/jsutils/isPromise.mjs","webpack://app/javascript/node_modules/graphql/jsutils/memoize3.mjs","webpack://app/javascript/node_modules/graphql/jsutils/promiseForObject.mjs","webpack://app/javascript/node_modules/graphql/jsutils/promiseReduce.mjs","webpack://app/javascript/node_modules/graphql/jsutils/toError.mjs","webpack://app/javascript/node_modules/graphql/error/locatedError.mjs","webpack://app/javascript/node_modules/graphql/execution/execute.mjs","webpack://app/javascript/node_modules/graphql/graphql.mjs","webpack://app/javascript/node_modules/graphql/jsutils/isAsyncIterable.mjs","webpack://app/javascript/node_modules/graphql/execution/mapAsyncIterator.mjs","webpack://app/javascript/node_modules/graphql/execution/subscribe.mjs","webpack://app/javascript/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs","webpack://app/javascript/node_modules/graphql/utilities/getOperationAST.mjs","webpack://app/javascript/node_modules/graphql/utilities/getOperationRootType.mjs","webpack://app/javascript/node_modules/graphql/utilities/introspectionFromSchema.mjs","webpack://app/javascript/node_modules/graphql/utilities/lexicographicSortSchema.mjs","webpack://app/javascript/node_modules/graphql/utilities/printSchema.mjs","webpack://app/javascript/node_modules/graphql/utilities/concatAST.mjs","webpack://app/javascript/node_modules/graphql/utilities/separateOperations.mjs","webpack://app/javascript/node_modules/graphql/utilities/stripIgnoredCharacters.mjs","webpack://app/javascript/node_modules/graphql/utilities/assertValidName.mjs","webpack://app/javascript/node_modules/graphql/utilities/findBreakingChanges.mjs"],"names":[],"mappings":"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","file":"static/9677.1883a510.chunk.js","sourcesContent":["// Note: This file is autogenerated using \"resources/gen-version.js\" script and\n// automatically updated by \"npm version\" command.\n\n/**\n * A string containing the version of the GraphQL.js library\n */\nexport const version = '16.4.0';\n/**\n * An object containing the components of the GraphQL.js version string\n */\n\nexport const versionInfo = Object.freeze({\n  major: 16,\n  minor: 4,\n  patch: 0,\n  preReleaseTag: null,\n});\n","/**\n * Returns true if the value acts like a Promise, i.e. has a \"then\" function,\n * otherwise returns false.\n */\nexport function isPromise(value) {\n  return (\n    typeof (value === null || value === void 0 ? void 0 : value.then) ===\n    'function'\n  );\n}\n","/**\n * Memoizes the provided three-argument function.\n */\nexport function memoize3(fn) {\n  let cache0;\n  return function memoized(a1, a2, a3) {\n    if (cache0 === undefined) {\n      cache0 = new WeakMap();\n    }\n\n    let cache1 = cache0.get(a1);\n\n    if (cache1 === undefined) {\n      cache1 = new WeakMap();\n      cache0.set(a1, cache1);\n    }\n\n    let cache2 = cache1.get(a2);\n\n    if (cache2 === undefined) {\n      cache2 = new WeakMap();\n      cache1.set(a2, cache2);\n    }\n\n    let fnResult = cache2.get(a3);\n\n    if (fnResult === undefined) {\n      fnResult = fn(a1, a2, a3);\n      cache2.set(a3, fnResult);\n    }\n\n    return fnResult;\n  };\n}\n","/**\n * This function transforms a JS object `ObjMap<Promise<T>>` into\n * a `Promise<ObjMap<T>>`\n *\n * This is akin to bluebird's `Promise.props`, but implemented only using\n * `Promise.all` so it will work with any implementation of ES6 promises.\n */\nexport function promiseForObject(object) {\n  return Promise.all(Object.values(object)).then((resolvedValues) => {\n    const resolvedObject = Object.create(null);\n\n    for (const [i, key] of Object.keys(object).entries()) {\n      resolvedObject[key] = resolvedValues[i];\n    }\n\n    return resolvedObject;\n  });\n}\n","import { isPromise } from './isPromise.mjs';\n\n/**\n * Similar to Array.prototype.reduce(), however the reducing callback may return\n * a Promise, in which case reduction will continue after each promise resolves.\n *\n * If the callback does not return a Promise, then this function will also not\n * return a Promise.\n */\nexport function promiseReduce(values, callbackFn, initialValue) {\n  let accumulator = initialValue;\n\n  for (const value of values) {\n    accumulator = isPromise(accumulator)\n      ? accumulator.then((resolved) => callbackFn(resolved, value))\n      : callbackFn(accumulator, value);\n  }\n\n  return accumulator;\n}\n","import { inspect } from './inspect.mjs';\n/**\n * Sometimes a non-error is thrown, wrap it as an Error instance to ensure a consistent Error interface.\n */\n\nexport function toError(thrownValue) {\n  return thrownValue instanceof Error\n    ? thrownValue\n    : new NonErrorThrown(thrownValue);\n}\n\nclass NonErrorThrown extends Error {\n  constructor(thrownValue) {\n    super('Unexpected error value: ' + inspect(thrownValue));\n    this.name = 'NonErrorThrown';\n    this.thrownValue = thrownValue;\n  }\n}\n","import { toError } from '../jsutils/toError.mjs';\nimport { GraphQLError } from './GraphQLError.mjs';\n/**\n * Given an arbitrary value, presumably thrown while attempting to execute a\n * GraphQL operation, produce a new GraphQLError aware of the location in the\n * document responsible for the original Error.\n */\n\nexport function locatedError(rawOriginalError, nodes, path) {\n  var _nodes;\n\n  const originalError = toError(rawOriginalError); // Note: this uses a brand-check to support GraphQL errors originating from other contexts.\n\n  if (isLocatedGraphQLError(originalError)) {\n    return originalError;\n  }\n\n  return new GraphQLError(originalError.message, {\n    nodes:\n      (_nodes = originalError.nodes) !== null && _nodes !== void 0\n        ? _nodes\n        : nodes,\n    source: originalError.source,\n    positions: originalError.positions,\n    path,\n    originalError,\n  });\n}\n\nfunction isLocatedGraphQLError(error) {\n  return Array.isArray(error.path);\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { isPromise } from '../jsutils/isPromise.mjs';\nimport { memoize3 } from '../jsutils/memoize3.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { promiseForObject } from '../jsutils/promiseForObject.mjs';\nimport { promiseReduce } from '../jsutils/promiseReduce.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isAbstractType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../type/definition.mjs';\nimport {\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef,\n} from '../type/introspection.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport {\n  collectFields,\n  collectSubfields as _collectSubfields,\n} from './collectFields.mjs';\nimport { getArgumentValues, getVariableValues } from './values.mjs';\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\n\nconst collectSubfields = memoize3((exeContext, returnType, fieldNodes) =>\n  _collectSubfields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    returnType,\n    fieldNodes,\n  ),\n);\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nexport function execute(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const { schema, document, variableValues, rootValue } = args; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  //\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n  try {\n    const { operation } = exeContext;\n    const result = executeOperation(exeContext, operation, rootValue);\n\n    if (isPromise(result)) {\n      return result.then(\n        (data) => buildResponse(data, exeContext.errors),\n        (error) => {\n          exeContext.errors.push(error);\n          return buildResponse(null, exeContext.errors);\n        },\n      );\n    }\n\n    return buildResponse(result, exeContext.errors);\n  } catch (error) {\n    exeContext.errors.push(error);\n    return buildResponse(null, exeContext.errors);\n  }\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function executeSync(args) {\n  const result = execute(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\nfunction buildResponse(data, errors) {\n  return errors.length === 0\n    ? {\n        data,\n      }\n    : {\n        errors,\n        data,\n      };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\n\nexport function assertValidExecutionArguments(\n  schema,\n  document,\n  rawVariableValues,\n) {\n  document || devAssert(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  assertValidSchema(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null ||\n    isObjectLike(rawVariableValues) ||\n    devAssert(\n      false,\n      'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.',\n    );\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\n\nexport function buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe;\n\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver,\n  } = args;\n  let operation;\n  const fragments = Object.create(null);\n\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [\n              new GraphQLError(\n                'Must provide operation name if query contains multiple operations.',\n              ),\n            ];\n          }\n\n          operation = definition;\n        } else if (\n          ((_definition$name = definition.name) === null ||\n          _definition$name === void 0\n            ? void 0\n            : _definition$name.value) === operationName\n        ) {\n          operation = definition;\n        }\n\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [new GraphQLError(`Unknown operation named \"${operationName}\".`)];\n    }\n\n    return [new GraphQLError('Must provide an operation.')];\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const variableDefinitions =\n    (_operation$variableDe = operation.variableDefinitions) !== null &&\n    _operation$variableDe !== void 0\n      ? _operation$variableDe\n      : [];\n  const coercedVariableValues = getVariableValues(\n    schema,\n    variableDefinitions,\n    rawVariableValues !== null && rawVariableValues !== void 0\n      ? rawVariableValues\n      : {},\n    {\n      maxErrors: 50,\n    },\n  );\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver:\n      fieldResolver !== null && fieldResolver !== void 0\n        ? fieldResolver\n        : defaultFieldResolver,\n    typeResolver:\n      typeResolver !== null && typeResolver !== void 0\n        ? typeResolver\n        : defaultTypeResolver,\n    subscribeFieldResolver:\n      subscribeFieldResolver !== null && subscribeFieldResolver !== void 0\n        ? subscribeFieldResolver\n        : defaultFieldResolver,\n    errors: [],\n  };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  const rootType = exeContext.schema.getRootType(operation.operation);\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      `Schema is not configured to execute ${operation.operation} operation.`,\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = collectFields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const path = undefined;\n\n  switch (operation.operation) {\n    case OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n\n    case OperationTypeNode.MUTATION:\n      return executeFieldsSerially(\n        exeContext,\n        rootType,\n        rootValue,\n        path,\n        rootFields,\n      );\n\n    case OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\n\nfunction executeFieldsSerially(\n  exeContext,\n  parentType,\n  sourceValue,\n  path,\n  fields,\n) {\n  return promiseReduce(\n    fields.entries(),\n    (results, [responseName, fieldNodes]) => {\n      const fieldPath = addPath(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldNodes,\n        fieldPath,\n      );\n\n      if (result === undefined) {\n        return results;\n      }\n\n      if (isPromise(result)) {\n        return result.then((resolvedResult) => {\n          results[responseName] = resolvedResult;\n          return results;\n        });\n      }\n\n      results[responseName] = result;\n      return results;\n    },\n    Object.create(null),\n  );\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  const results = Object.create(null);\n  let containsPromise = false;\n\n  for (const [responseName, fieldNodes] of fields.entries()) {\n    const fieldPath = addPath(path, responseName, parentType.name);\n    const result = executeField(\n      exeContext,\n      parentType,\n      sourceValue,\n      fieldNodes,\n      fieldPath,\n    );\n\n    if (result !== undefined) {\n      results[responseName] = result;\n\n      if (isPromise(result)) {\n        containsPromise = true;\n      }\n    }\n  } // If there are no promises, we can just return the object\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n  return promiseForObject(results);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\n\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  const returnType = fieldDef.type;\n  const resolveFn =\n    (_fieldDef$resolve = fieldDef.resolve) !== null &&\n    _fieldDef$resolve !== void 0\n      ? _fieldDef$resolve\n      : exeContext.fieldResolver;\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    parentType,\n    path,\n  ); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    const args = getArgumentValues(\n      fieldDef,\n      fieldNodes[0],\n      exeContext.variableValues,\n    ); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue;\n    const result = resolveFn(source, args, contextValue, info);\n    let completed;\n\n    if (isPromise(result)) {\n      completed = result.then((resolved) =>\n        completeValue(exeContext, returnType, fieldNodes, info, path, resolved),\n      );\n    } else {\n      completed = completeValue(\n        exeContext,\n        returnType,\n        fieldNodes,\n        info,\n        path,\n        result,\n      );\n    }\n\n    if (isPromise(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, (rawError) => {\n        const error = locatedError(rawError, fieldNodes, pathToArray(path));\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (rawError) {\n    const error = locatedError(rawError, fieldNodes, pathToArray(path));\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\n * @internal\n */\n\nexport function buildResolveInfo(\n  exeContext,\n  fieldDef,\n  fieldNodes,\n  parentType,\n  path,\n) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues,\n  };\n}\n\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if (isNonNullType(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n  if (isNonNullType(returnType)) {\n    const completed = completeValue(\n      exeContext,\n      returnType.ofType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n\n    if (completed === null) {\n      throw new Error(\n        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`,\n      );\n    }\n\n    return completed;\n  } // If result value is null or undefined then return null.\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n  if (isListType(returnType)) {\n    return completeListValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n  if (isLeafType(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is Object, execute and complete all sub-selections.\n\n  if (isObjectType(returnType)) {\n    return completeObjectValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n\n  false ||\n    invariant(\n      false,\n      'Cannot complete value of unexpected output type: ' + inspect(returnType),\n    );\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\nfunction completeListValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  if (!isIterableObject(result)) {\n    throw new GraphQLError(\n      `Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`,\n    );\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = Array.from(result, (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const itemPath = addPath(path, index, undefined);\n\n    try {\n      let completedItem;\n\n      if (isPromise(item)) {\n        completedItem = item.then((resolved) =>\n          completeValue(\n            exeContext,\n            itemType,\n            fieldNodes,\n            info,\n            itemPath,\n            resolved,\n          ),\n        );\n      } else {\n        completedItem = completeValue(\n          exeContext,\n          itemType,\n          fieldNodes,\n          info,\n          itemPath,\n          item,\n        );\n      }\n\n      if (isPromise(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, (rawError) => {\n          const error = locatedError(\n            rawError,\n            fieldNodes,\n            pathToArray(itemPath),\n          );\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n\n      return completedItem;\n    } catch (rawError) {\n      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\nfunction completeLeafValue(returnType, result) {\n  const serializedResult = returnType.serialize(result);\n\n  if (serializedResult == null) {\n    throw new Error(\n      `Expected \\`${inspect(returnType)}.serialize(${inspect(result)})\\` to ` +\n        `return non-nullable value, returned: ${inspect(serializedResult)}`,\n    );\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\nfunction completeAbstractValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  var _returnType$resolveTy;\n\n  const resolveTypeFn =\n    (_returnType$resolveTy = returnType.resolveType) !== null &&\n    _returnType$resolveTy !== void 0\n      ? _returnType$resolveTy\n      : exeContext.typeResolver;\n  const contextValue = exeContext.contextValue;\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if (isPromise(runtimeType)) {\n    return runtimeType.then((resolvedRuntimeType) =>\n      completeObjectValue(\n        exeContext,\n        ensureValidRuntimeType(\n          resolvedRuntimeType,\n          exeContext,\n          returnType,\n          fieldNodes,\n          info,\n          result,\n        ),\n        fieldNodes,\n        info,\n        path,\n        result,\n      ),\n    );\n  }\n\n  return completeObjectValue(\n    exeContext,\n    ensureValidRuntimeType(\n      runtimeType,\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      result,\n    ),\n    fieldNodes,\n    info,\n    path,\n    result,\n  );\n}\n\nfunction ensureValidRuntimeType(\n  runtimeTypeName,\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  result,\n) {\n  if (runtimeTypeName == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`,\n      fieldNodes,\n    );\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n  // TODO: remove in 17.0.0 release\n\n  if (isObjectType(runtimeTypeName)) {\n    throw new GraphQLError(\n      'Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.',\n    );\n  }\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` +\n        `value ${inspect(result)}, received \"${inspect(runtimeTypeName)}\".`,\n    );\n  }\n\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\n\n  if (runtimeType == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new GraphQLError(\n      `Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\nfunction completeObjectValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  // Collect sub-fields to execute to complete this value.\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if (isPromise(isTypeOf)) {\n      return isTypeOf.then((resolvedIsTypeOf) => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return executeFields(\n          exeContext,\n          returnType,\n          result,\n          path,\n          subFieldNodes,\n        );\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new GraphQLError(\n    `Expected value of type \"${returnType.name}\" but got: ${inspect(result)}.`,\n    {\n      nodes: fieldNodes,\n    },\n  );\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\nexport const defaultTypeResolver = function (\n  value,\n  contextValue,\n  info,\n  abstractType,\n) {\n  // First, look for `__typename`.\n  if (isObjectLike(value) && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if (isPromise(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type.name;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\nexport const defaultFieldResolver = function (\n  source,\n  args,\n  contextValue,\n  info,\n) {\n  // ensure source is a value for which property access is acceptable.\n  if (isObjectLike(source) || typeof source === 'function') {\n    const property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\n\nexport function getFieldDef(schema, parentType, fieldNode) {\n  const fieldName = fieldNode.name.value;\n\n  if (\n    fieldName === SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return SchemaMetaFieldDef;\n  } else if (\n    fieldName === TypeMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}\n","import { devAssert } from './jsutils/devAssert.mjs';\nimport { isPromise } from './jsutils/isPromise.mjs';\nimport { parse } from './language/parser.mjs';\nimport { validateSchema } from './type/validate.mjs';\nimport { validate } from './validation/validate.mjs';\nimport { execute } from './execution/execute.mjs';\n/**\n * This is the primary entry point function for fulfilling GraphQL operations\n * by parsing, validating, and executing a GraphQL document along side a\n * GraphQL schema.\n *\n * More sophisticated GraphQL servers, such as those which persist queries,\n * may wish to separate the validation and execution phases to a static time\n * tooling step, and a server runtime step.\n *\n * Accepts either an object with named arguments, or individual arguments:\n *\n * schema:\n *    The GraphQL type system to use when validating and executing a query.\n * source:\n *    A GraphQL language formatted string representing the requested operation.\n * rootValue:\n *    The value provided as the first argument to resolver functions on the top\n *    level type (e.g. the query object type).\n * contextValue:\n *    The context value is provided as an argument to resolver functions after\n *    field arguments. It is used to pass shared information useful at any point\n *    during executing this query, for example the currently logged in user and\n *    connections to databases or other services.\n * variableValues:\n *    A mapping of variable name to runtime value to use for all variables\n *    defined in the requestString.\n * operationName:\n *    The name of the operation to use if requestString contains multiple\n *    possible operations. Can be omitted if requestString contains only\n *    one operation.\n * fieldResolver:\n *    A resolver function to use when one is not provided by the schema.\n *    If not provided, the default field resolver is used (which looks for a\n *    value or method on the source value with the field's name).\n * typeResolver:\n *    A type resolver function to use when none is provided by the schema.\n *    If not provided, the default type resolver is used (which looks for a\n *    `__typename` field or alternatively calls the `isTypeOf` method).\n */\n\nexport function graphql(args) {\n  // Always return a Promise for a consistent API.\n  return new Promise((resolve) => resolve(graphqlImpl(args)));\n}\n/**\n * The graphqlSync function also fulfills GraphQL operations by parsing,\n * validating, and executing a GraphQL document along side a GraphQL schema.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function graphqlSync(args) {\n  const result = graphqlImpl(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n\nfunction graphqlImpl(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const {\n    schema,\n    source,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n  } = args; // Validate Schema\n\n  const schemaValidationErrors = validateSchema(schema);\n\n  if (schemaValidationErrors.length > 0) {\n    return {\n      errors: schemaValidationErrors,\n    };\n  } // Parse\n\n  let document;\n\n  try {\n    document = parse(source);\n  } catch (syntaxError) {\n    return {\n      errors: [syntaxError],\n    };\n  } // Validate\n\n  const validationErrors = validate(schema, document);\n\n  if (validationErrors.length > 0) {\n    return {\n      errors: validationErrors,\n    };\n  } // Execute\n\n  return execute({\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n  });\n}\n","/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * implementing a `Symbol.asyncIterator` method.\n */\nexport function isAsyncIterable(maybeAsyncIterable) {\n  return (\n    typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0\n      ? void 0\n      : maybeAsyncIterable[Symbol.asyncIterator]) === 'function'\n  );\n}\n","/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport function mapAsyncIterator(iterable, callback) {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  async function mapResult(result) {\n    if (result.done) {\n      return result;\n    }\n\n    try {\n      return {\n        value: await callback(result.value),\n        done: false,\n      };\n    } catch (error) {\n      /* c8 ignore start */\n      // FIXME: add test case\n      if (typeof iterator.return === 'function') {\n        try {\n          await iterator.return();\n        } catch (_e) {\n          /* ignore error */\n        }\n      }\n\n      throw error;\n      /* c8 ignore stop */\n    }\n  }\n\n  return {\n    async next() {\n      return mapResult(await iterator.next());\n    },\n\n    async return() {\n      // If iterator.return() does not exist, then type R must be undefined.\n      return typeof iterator.return === 'function'\n        ? mapResult(await iterator.return())\n        : {\n            value: undefined,\n            done: true,\n          };\n    },\n\n    async throw(error) {\n      if (typeof iterator.throw === 'function') {\n        return mapResult(await iterator.throw(error));\n      }\n\n      throw error;\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isAsyncIterable } from '../jsutils/isAsyncIterable.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { collectFields } from './collectFields.mjs';\nimport {\n  assertValidExecutionArguments,\n  buildExecutionContext,\n  buildResolveInfo,\n  execute,\n  getFieldDef,\n} from './execute.mjs';\nimport { mapAsyncIterator } from './mapAsyncIterator.mjs';\nimport { getArgumentValues } from './values.mjs';\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\n\nexport async function subscribe(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    fieldResolver,\n    subscribeFieldResolver,\n  } = args;\n  const resultOrStream = await createSourceEventStream(\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    subscribeFieldResolver,\n  );\n\n  if (!isAsyncIterable(resultOrStream)) {\n    return resultOrStream;\n  } // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  const mapSourceToResponse = (payload) =>\n    execute({\n      schema,\n      document,\n      rootValue: payload,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver,\n    }); // Map every source value to a ExecutionResult value as described above.\n\n  return mapAsyncIterator(resultOrStream, mapSourceToResponse);\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\nexport async function createSourceEventStream(\n  schema,\n  document,\n  rootValue,\n  contextValue,\n  variableValues,\n  operationName,\n  subscribeFieldResolver,\n) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext({\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    subscribeFieldResolver,\n  }); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  }\n\n  try {\n    const eventStream = await executeSubscription(exeContext); // Assert field returned an event stream, otherwise yield an error.\n\n    if (!isAsyncIterable(eventStream)) {\n      throw new Error(\n        'Subscription field must return Async Iterable. ' +\n          `Received: ${inspect(eventStream)}.`,\n      );\n    }\n\n    return eventStream;\n  } catch (error) {\n    // If it GraphQLError, report it as an ExecutionResult, containing only errors and no data.\n    // Otherwise treat the error as a system-class error and re-throw it.\n    if (error instanceof GraphQLError) {\n      return {\n        errors: [error],\n      };\n    }\n\n    throw error;\n  }\n}\n\nasync function executeSubscription(exeContext) {\n  const { schema, fragments, operation, variableValues, rootValue } =\n    exeContext;\n  const rootType = schema.getSubscriptionType();\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      'Schema is not configured to execute subscription operation.',\n      {\n        nodes: operation,\n      },\n    );\n  }\n\n  const rootFields = collectFields(\n    schema,\n    fragments,\n    variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const [responseName, fieldNodes] = [...rootFields.entries()][0];\n  const fieldDef = getFieldDef(schema, rootType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    const fieldName = fieldNodes[0].name.value;\n    throw new GraphQLError(\n      `The subscription field \"${fieldName}\" is not defined.`,\n      {\n        nodes: fieldNodes,\n      },\n    );\n  }\n\n  const path = addPath(undefined, responseName, rootType.name);\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    rootType,\n    path,\n  );\n\n  try {\n    var _fieldDef$subscribe;\n\n    // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n    // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue; // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n    const resolveFn =\n      (_fieldDef$subscribe = fieldDef.subscribe) !== null &&\n      _fieldDef$subscribe !== void 0\n        ? _fieldDef$subscribe\n        : exeContext.subscribeFieldResolver;\n    const eventStream = await resolveFn(rootValue, args, contextValue, info);\n\n    if (eventStream instanceof Error) {\n      throw eventStream;\n    }\n\n    return eventStream;\n  } catch (error) {\n    throw locatedError(error, fieldNodes, pathToArray(path));\n  }\n}\n","import { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType } from '../../../type/definition.mjs';\nimport { isIntrospectionType } from '../../../type/introspection.mjs';\n\n/**\n * Prohibit introspection queries\n *\n * A GraphQL document is only valid if all fields selected are not fields that\n * return an introspection type.\n *\n * Note: This rule is optional and is not part of the Validation section of the\n * GraphQL Specification. This rule effectively disables introspection, which\n * does not reflect best practices and should only be done if absolutely necessary.\n */\nexport function NoSchemaIntrospectionCustomRule(context) {\n  return {\n    Field(node) {\n      const type = getNamedType(context.getType());\n\n      if (type && isIntrospectionType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `GraphQL introspection has been disabled, but the requested query contained the field \"${node.name.value}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { Kind } from '../language/kinds.mjs';\n/**\n * Returns an operation AST given a document AST and optionally an operation\n * name. If a name is not provided, an operation is only returned if only one is\n * provided in the document.\n */\n\nexport function getOperationAST(documentAST, operationName) {\n  let operation = null;\n\n  for (const definition of documentAST.definitions) {\n    if (definition.kind === Kind.OPERATION_DEFINITION) {\n      var _definition$name;\n\n      if (operationName == null) {\n        // If no operation name was provided, only return an Operation if there\n        // is one defined in the document. Upon encountering the second, return\n        // null.\n        if (operation) {\n          return null;\n        }\n\n        operation = definition;\n      } else if (\n        ((_definition$name = definition.name) === null ||\n        _definition$name === void 0\n          ? void 0\n          : _definition$name.value) === operationName\n      ) {\n        return definition;\n      }\n    }\n  }\n\n  return operation;\n}\n","import { GraphQLError } from '../error/GraphQLError.mjs';\n\n/**\n * Extracts the root type of the operation from the schema.\n *\n * @deprecated Please use `GraphQLSchema.getRootType` instead. Will be removed in v17\n */\nexport function getOperationRootType(schema, operation) {\n  if (operation.operation === 'query') {\n    const queryType = schema.getQueryType();\n\n    if (!queryType) {\n      throw new GraphQLError(\n        'Schema does not define the required query root type.',\n        {\n          nodes: operation,\n        },\n      );\n    }\n\n    return queryType;\n  }\n\n  if (operation.operation === 'mutation') {\n    const mutationType = schema.getMutationType();\n\n    if (!mutationType) {\n      throw new GraphQLError('Schema is not configured for mutations.', {\n        nodes: operation,\n      });\n    }\n\n    return mutationType;\n  }\n\n  if (operation.operation === 'subscription') {\n    const subscriptionType = schema.getSubscriptionType();\n\n    if (!subscriptionType) {\n      throw new GraphQLError('Schema is not configured for subscriptions.', {\n        nodes: operation,\n      });\n    }\n\n    return subscriptionType;\n  }\n\n  throw new GraphQLError(\n    'Can only have query, mutation and subscription operations.',\n    {\n      nodes: operation,\n    },\n  );\n}\n","import { invariant } from '../jsutils/invariant.mjs';\nimport { parse } from '../language/parser.mjs';\nimport { executeSync } from '../execution/execute.mjs';\nimport { getIntrospectionQuery } from './getIntrospectionQuery.mjs';\n/**\n * Build an IntrospectionQuery from a GraphQLSchema\n *\n * IntrospectionQuery is useful for utilities that care about type and field\n * relationships, but do not need to traverse through those relationships.\n *\n * This is the inverse of buildClientSchema. The primary use case is outside\n * of the server context, for instance when doing schema comparisons.\n */\n\nexport function introspectionFromSchema(schema, options) {\n  const optionsWithDefaults = {\n    specifiedByUrl: true,\n    directiveIsRepeatable: true,\n    schemaDescription: true,\n    inputValueDeprecation: true,\n    ...options,\n  };\n  const document = parse(getIntrospectionQuery(optionsWithDefaults));\n  const result = executeSync({\n    schema,\n    document,\n  });\n  (!result.errors && result.data) || invariant(false);\n  return result.data;\n}\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLUnionType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { isIntrospectionType } from '../type/introspection.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\n/**\n * Sort GraphQLSchema.\n *\n * This function returns a sorted copy of the given GraphQLSchema.\n */\n\nexport function lexicographicSortSchema(schema) {\n  const schemaConfig = schema.toConfig();\n  const typeMap = keyValMap(\n    sortByName(schemaConfig.types),\n    (type) => type.name,\n    sortNamedType,\n  );\n  return new GraphQLSchema({\n    ...schemaConfig,\n    types: Object.values(typeMap),\n    directives: sortByName(schemaConfig.directives).map(sortDirective),\n    query: replaceMaybeType(schemaConfig.query),\n    mutation: replaceMaybeType(schemaConfig.mutation),\n    subscription: replaceMaybeType(schemaConfig.subscription),\n  });\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME: TS Conversion\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function replaceMaybeType(maybeType) {\n    return maybeType && replaceNamedType(maybeType);\n  }\n\n  function sortDirective(directive) {\n    const config = directive.toConfig();\n    return new GraphQLDirective({\n      ...config,\n      locations: sortBy(config.locations, (x) => x),\n      args: sortArgs(config.args),\n    });\n  }\n\n  function sortArgs(args) {\n    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));\n  }\n\n  function sortFields(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => ({\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && sortArgs(field.args),\n    }));\n  }\n\n  function sortInputFields(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => ({\n      ...field,\n      type: replaceType(field.type),\n    }));\n  }\n\n  function sortTypes(array) {\n    return sortByName(array).map(replaceNamedType);\n  }\n\n  function sortNamedType(type) {\n    if (isScalarType(type) || isIntrospectionType(type)) {\n      return type;\n    }\n\n    if (isObjectType(type)) {\n      const config = type.toConfig();\n      return new GraphQLObjectType({\n        ...config,\n        interfaces: () => sortTypes(config.interfaces),\n        fields: () => sortFields(config.fields),\n      });\n    }\n\n    if (isInterfaceType(type)) {\n      const config = type.toConfig();\n      return new GraphQLInterfaceType({\n        ...config,\n        interfaces: () => sortTypes(config.interfaces),\n        fields: () => sortFields(config.fields),\n      });\n    }\n\n    if (isUnionType(type)) {\n      const config = type.toConfig();\n      return new GraphQLUnionType({\n        ...config,\n        types: () => sortTypes(config.types),\n      });\n    }\n\n    if (isEnumType(type)) {\n      const config = type.toConfig();\n      return new GraphQLEnumType({\n        ...config,\n        values: sortObjMap(config.values, (value) => value),\n      });\n    }\n\n    if (isInputObjectType(type)) {\n      const config = type.toConfig();\n      return new GraphQLInputObjectType({\n        ...config,\n        fields: () => sortInputFields(config.fields),\n      });\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible types have been considered.\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n}\n\nfunction sortObjMap(map, sortValueFn) {\n  const sortedMap = Object.create(null);\n\n  for (const key of Object.keys(map).sort(naturalCompare)) {\n    sortedMap[key] = sortValueFn(map[key]);\n  }\n\n  return sortedMap;\n}\n\nfunction sortByName(array) {\n  return sortBy(array, (obj) => obj.name);\n}\n\nfunction sortBy(array, mapToKey) {\n  return array.slice().sort((obj1, obj2) => {\n    const key1 = mapToKey(obj1);\n    const key2 = mapToKey(obj2);\n    return naturalCompare(key1, key2);\n  });\n}\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isPrintableAsBlockString } from '../language/blockString.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport {\n  DEFAULT_DEPRECATION_REASON,\n  isSpecifiedDirective,\n} from '../type/directives.mjs';\nimport { isIntrospectionType } from '../type/introspection.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nexport function printSchema(schema) {\n  return printFilteredSchema(\n    schema,\n    (n) => !isSpecifiedDirective(n),\n    isDefinedType,\n  );\n}\nexport function printIntrospectionSchema(schema) {\n  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);\n}\n\nfunction isDefinedType(type) {\n  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);\n}\n\nfunction printFilteredSchema(schema, directiveFilter, typeFilter) {\n  const directives = schema.getDirectives().filter(directiveFilter);\n  const types = Object.values(schema.getTypeMap()).filter(typeFilter);\n  return [\n    printSchemaDefinition(schema),\n    ...directives.map((directive) => printDirective(directive)),\n    ...types.map((type) => printType(type)),\n  ]\n    .filter(Boolean)\n    .join('\\n\\n');\n}\n\nfunction printSchemaDefinition(schema) {\n  if (schema.description == null && isSchemaOfCommonNames(schema)) {\n    return;\n  }\n\n  const operationTypes = [];\n  const queryType = schema.getQueryType();\n\n  if (queryType) {\n    operationTypes.push(`  query: ${queryType.name}`);\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    operationTypes.push(`  mutation: ${mutationType.name}`);\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    operationTypes.push(`  subscription: ${subscriptionType.name}`);\n  }\n\n  return printDescription(schema) + `schema {\\n${operationTypes.join('\\n')}\\n}`;\n}\n/**\n * GraphQL schema define root types for each type of operation. These types are\n * the same as any other type and can be named in any manner, however there is\n * a common naming convention:\n *\n * ```graphql\n *   schema {\n *     query: Query\n *     mutation: Mutation\n *     subscription: Subscription\n *   }\n * ```\n *\n * When using this naming convention, the schema description can be omitted.\n */\n\nfunction isSchemaOfCommonNames(schema) {\n  const queryType = schema.getQueryType();\n\n  if (queryType && queryType.name !== 'Query') {\n    return false;\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && mutationType.name !== 'Mutation') {\n    return false;\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && subscriptionType.name !== 'Subscription') {\n    return false;\n  }\n\n  return true;\n}\n\nexport function printType(type) {\n  if (isScalarType(type)) {\n    return printScalar(type);\n  }\n\n  if (isObjectType(type)) {\n    return printObject(type);\n  }\n\n  if (isInterfaceType(type)) {\n    return printInterface(type);\n  }\n\n  if (isUnionType(type)) {\n    return printUnion(type);\n  }\n\n  if (isEnumType(type)) {\n    return printEnum(type);\n  }\n\n  if (isInputObjectType(type)) {\n    return printInputObject(type);\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction printScalar(type) {\n  return (\n    printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type)\n  );\n}\n\nfunction printImplementedInterfaces(type) {\n  const interfaces = type.getInterfaces();\n  return interfaces.length\n    ? ' implements ' + interfaces.map((i) => i.name).join(' & ')\n    : '';\n}\n\nfunction printObject(type) {\n  return (\n    printDescription(type) +\n    `type ${type.name}` +\n    printImplementedInterfaces(type) +\n    printFields(type)\n  );\n}\n\nfunction printInterface(type) {\n  return (\n    printDescription(type) +\n    `interface ${type.name}` +\n    printImplementedInterfaces(type) +\n    printFields(type)\n  );\n}\n\nfunction printUnion(type) {\n  const types = type.getTypes();\n  const possibleTypes = types.length ? ' = ' + types.join(' | ') : '';\n  return printDescription(type) + 'union ' + type.name + possibleTypes;\n}\n\nfunction printEnum(type) {\n  const values = type\n    .getValues()\n    .map(\n      (value, i) =>\n        printDescription(value, '  ', !i) +\n        '  ' +\n        value.name +\n        printDeprecated(value.deprecationReason),\n    );\n  return printDescription(type) + `enum ${type.name}` + printBlock(values);\n}\n\nfunction printInputObject(type) {\n  const fields = Object.values(type.getFields()).map(\n    (f, i) => printDescription(f, '  ', !i) + '  ' + printInputValue(f),\n  );\n  return printDescription(type) + `input ${type.name}` + printBlock(fields);\n}\n\nfunction printFields(type) {\n  const fields = Object.values(type.getFields()).map(\n    (f, i) =>\n      printDescription(f, '  ', !i) +\n      '  ' +\n      f.name +\n      printArgs(f.args, '  ') +\n      ': ' +\n      String(f.type) +\n      printDeprecated(f.deprecationReason),\n  );\n  return printBlock(fields);\n}\n\nfunction printBlock(items) {\n  return items.length !== 0 ? ' {\\n' + items.join('\\n') + '\\n}' : '';\n}\n\nfunction printArgs(args, indentation = '') {\n  if (args.length === 0) {\n    return '';\n  } // If every arg does not have a description, print them on one line.\n\n  if (args.every((arg) => !arg.description)) {\n    return '(' + args.map(printInputValue).join(', ') + ')';\n  }\n\n  return (\n    '(\\n' +\n    args\n      .map(\n        (arg, i) =>\n          printDescription(arg, '  ' + indentation, !i) +\n          '  ' +\n          indentation +\n          printInputValue(arg),\n      )\n      .join('\\n') +\n    '\\n' +\n    indentation +\n    ')'\n  );\n}\n\nfunction printInputValue(arg) {\n  const defaultAST = astFromValue(arg.defaultValue, arg.type);\n  let argDecl = arg.name + ': ' + String(arg.type);\n\n  if (defaultAST) {\n    argDecl += ` = ${print(defaultAST)}`;\n  }\n\n  return argDecl + printDeprecated(arg.deprecationReason);\n}\n\nfunction printDirective(directive) {\n  return (\n    printDescription(directive) +\n    'directive @' +\n    directive.name +\n    printArgs(directive.args) +\n    (directive.isRepeatable ? ' repeatable' : '') +\n    ' on ' +\n    directive.locations.join(' | ')\n  );\n}\n\nfunction printDeprecated(reason) {\n  if (reason == null) {\n    return '';\n  }\n\n  if (reason !== DEFAULT_DEPRECATION_REASON) {\n    const astValue = print({\n      kind: Kind.STRING,\n      value: reason,\n    });\n    return ` @deprecated(reason: ${astValue})`;\n  }\n\n  return ' @deprecated';\n}\n\nfunction printSpecifiedByURL(scalar) {\n  if (scalar.specifiedByURL == null) {\n    return '';\n  }\n\n  const astValue = print({\n    kind: Kind.STRING,\n    value: scalar.specifiedByURL,\n  });\n  return ` @specifiedBy(url: ${astValue})`;\n}\n\nfunction printDescription(def, indentation = '', firstInBlock = true) {\n  const { description } = def;\n\n  if (description == null) {\n    return '';\n  }\n\n  const blockString = print({\n    kind: Kind.STRING,\n    value: description,\n    block: isPrintableAsBlockString(description),\n  });\n  const prefix =\n    indentation && !firstInBlock ? '\\n' + indentation : indentation;\n  return prefix + blockString.replace(/\\n/g, '\\n' + indentation) + '\\n';\n}\n","import { Kind } from '../language/kinds.mjs';\n/**\n * Provided a collection of ASTs, presumably each from different files,\n * concatenate the ASTs together into batched AST, useful for validating many\n * GraphQL source files which together represent one conceptual application.\n */\n\nexport function concatAST(documents) {\n  const definitions = [];\n\n  for (const doc of documents) {\n    definitions.push(...doc.definitions);\n  }\n\n  return {\n    kind: Kind.DOCUMENT,\n    definitions,\n  };\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(\n          definitionNode.selectionSet,\n        );\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  const separatedDocumentASTs = Object.create(null);\n\n  for (const operation of operations) {\n    const dependencies = new Set();\n\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n    const operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(\n        (node) =>\n          node === operation ||\n          (node.kind === Kind.FRAGMENT_DEFINITION &&\n            dependencies.has(node.name.value)),\n      ),\n    };\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    },\n  });\n  return dependencies;\n}\n","import { printBlockString } from '../language/blockString.mjs';\nimport { isPunctuatorTokenKind, Lexer } from '../language/lexer.mjs';\nimport { isSource, Source } from '../language/source.mjs';\nimport { TokenKind } from '../language/tokenKind.mjs';\n/**\n * Strips characters that are not significant to the validity or execution\n * of a GraphQL document:\n *   - UnicodeBOM\n *   - WhiteSpace\n *   - LineTerminator\n *   - Comment\n *   - Comma\n *   - BlockString indentation\n *\n * Note: It is required to have a delimiter character between neighboring\n * non-punctuator tokens and this function always uses single space as delimiter.\n *\n * It is guaranteed that both input and output documents if parsed would result\n * in the exact same AST except for nodes location.\n *\n * Warning: It is guaranteed that this function will always produce stable results.\n * However, it's not guaranteed that it will stay the same between different\n * releases due to bugfixes or changes in the GraphQL specification.\n *\n * Query example:\n *\n * ```graphql\n * query SomeQuery($foo: String!, $bar: String) {\n *   someField(foo: $foo, bar: $bar) {\n *     a\n *     b {\n *       c\n *       d\n *     }\n *   }\n * }\n * ```\n *\n * Becomes:\n *\n * ```graphql\n * query SomeQuery($foo:String!$bar:String){someField(foo:$foo bar:$bar){a b{c d}}}\n * ```\n *\n * SDL example:\n *\n * ```graphql\n * \"\"\"\n * Type description\n * \"\"\"\n * type Foo {\n *   \"\"\"\n *   Field description\n *   \"\"\"\n *   bar: String\n * }\n * ```\n *\n * Becomes:\n *\n * ```graphql\n * \"\"\"Type description\"\"\" type Foo{\"\"\"Field description\"\"\" bar:String}\n * ```\n */\n\nexport function stripIgnoredCharacters(source) {\n  const sourceObj = isSource(source) ? source : new Source(source);\n  const body = sourceObj.body;\n  const lexer = new Lexer(sourceObj);\n  let strippedBody = '';\n  let wasLastAddedTokenNonPunctuator = false;\n\n  while (lexer.advance().kind !== TokenKind.EOF) {\n    const currentToken = lexer.token;\n    const tokenKind = currentToken.kind;\n    /**\n     * Every two non-punctuator tokens should have space between them.\n     * Also prevent case of non-punctuator token following by spread resulting\n     * in invalid token (e.g. `1...` is invalid Float token).\n     */\n\n    const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);\n\n    if (wasLastAddedTokenNonPunctuator) {\n      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {\n        strippedBody += ' ';\n      }\n    }\n\n    const tokenBody = body.slice(currentToken.start, currentToken.end);\n\n    if (tokenKind === TokenKind.BLOCK_STRING) {\n      strippedBody += printBlockString(currentToken.value, {\n        minimize: true,\n      });\n    } else {\n      strippedBody += tokenBody;\n    }\n\n    wasLastAddedTokenNonPunctuator = isNonPunctuator;\n  }\n\n  return strippedBody;\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { assertName } from '../type/assertName.mjs';\n/* c8 ignore start */\n\n/**\n * Upholds the spec rules about naming.\n * @deprecated Please use `assertName` instead. Will be removed in v17\n */\n\nexport function assertValidName(name) {\n  const error = isValidNameError(name);\n\n  if (error) {\n    throw error;\n  }\n\n  return name;\n}\n/**\n * Returns an Error if a name is invalid.\n * @deprecated Please use `assertName` instead. Will be removed in v17\n */\n\nexport function isValidNameError(name) {\n  typeof name === 'string' || devAssert(false, 'Expected name to be a string.');\n\n  if (name.startsWith('__')) {\n    return new GraphQLError(\n      `Name \"${name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n    );\n  }\n\n  try {\n    assertName(name);\n  } catch (error) {\n    return error;\n  }\n}\n/* c8 ignore stop */\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { print } from '../language/printer.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nimport { sortValueNode } from './sortValueNode.mjs';\nexport let BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] =\n    'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] =\n    'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] =\n    'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] =\n    'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] =\n    'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (BreakingChangeType = {}));\n\nexport let DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] =\n    'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] =\n    'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (DangerousChangeType = {}));\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in BreakingChangeType,\n  );\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in DangerousChangeType,\n  );\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [\n    ...findTypeChanges(oldSchema, newSchema),\n    ...findDirectiveChanges(oldSchema, newSchema),\n  ];\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(\n    oldSchema.getDirectives(),\n    newSchema.getDirectives(),\n  );\n\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`,\n    });\n  }\n\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n\n    for (const newArg of argsDiff.added) {\n      if (isRequiredArgument(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`,\n        });\n      }\n    }\n\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`,\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(\n    Object.values(oldSchema.getTypeMap()),\n    Object.values(newSchema.getTypeMap()),\n  );\n\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType)\n        ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.`\n        : `${oldType.name} was removed.`,\n    });\n  }\n\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (isEnumType(oldType) && isEnumType(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (isUnionType(oldType) && isUnionType(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (isObjectType(oldType) && isObjectType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description:\n          `${oldType.name} changed from ` +\n          `${typeKindName(oldType)} to ${typeKindName(newType)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const newField of fieldsDiff.added) {\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    }\n  }\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`,\n    });\n  }\n\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`,\n    });\n  }\n\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldArg.type,\n      newArg.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` +\n          `${String(oldArg.type)} to ${String(newArg.type)}.`,\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`,\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`,\n          });\n        }\n      }\n    }\n  }\n\n  for (const newArg of argsDiff.added) {\n    if (isRequiredArgument(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      (isListType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from nullable to non-null of the same underlying type is safe\n      (isNonNullType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (\n      isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType)\n    );\n  }\n\n  return (\n    // if they're both named types, see if their names are equivalent\n    (isNamedType(newType) && oldType.name === newType.name) || // moving from nullable to non-null of the same underlying type is safe\n    (isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (\n      isListType(newType) &&\n      isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType)\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      (isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from non-null to nullable of the same underlying type is safe\n      (!isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType))\n    );\n  } // if they're both named types, see if their names are equivalent\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction stringifyValue(value, type) {\n  const ast = astFromValue(value, type);\n  ast != null || invariant(false);\n  return print(sortValueNode(ast));\n}\n\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = keyMap(oldArray, ({ name }) => name);\n  const newMap = keyMap(newArray, ({ name }) => name);\n\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n\n  return {\n    added,\n    persisted,\n    removed,\n  };\n}\n"],"sourceRoot":""}